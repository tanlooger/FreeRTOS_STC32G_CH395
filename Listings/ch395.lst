C251 COMPILER V5.60.0,  CH395                                                              24/03/23  00:55:41  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE CH395
OBJECT MODULE PLACED IN .\Objects\CH395.obj
COMPILER INVOKED BY: C:\Keil_v5\C251\BIN\C251.EXE Sources\ch395\CH395.C XSMALL FUNCTIONS(REENTRANT) OPTIMIZE(4,SPEED) BR
                    -OWSE INCDIR(.\Sources\User;.\Sources\User\include;.\Sources\FreeRTOS\include;.\Sources\FreeRTOS\portable\STC32G12K128;.\
                    -Sources\Driver\inc;.\Sources\Task\inc;.\Sources\ch395) DEBUG PRINT(.\Listings\CH395.lst) TABS(2) OBJECT(.\Objects\CH395.
                    -obj) 

stmt  level    source

    1          /********************************** (C) COPYRIGHT *********************************
    2          * File Name          : CH395.c
    3          * Author             : WCH
    4          * Version            : V1.1
    5          * Date               : 2014/8/1
    6          * Description        : CH395åŸºæœ¬å‡½æ•°                      
    7          **********************************************************************************/
    8          #include <stdio.h>
    9          #include <string.h>
   10          #include <stdlib.h>
   11          //#include "..\SRC\CH563SFR.H"
   12          //#include "..\SRC\SYSFREQ.H"
   13          #include "CH395INC.H"
   14          #include "CH395.H"
   15          #include "ch395cmd.h"
   16          
   17          struct  _SOCK_INF  SockInf;
   18          struct  _CH395_SYS  CH395Inf;  
   19             
   20          /*******************************************************************************
   21          * Function Name  : InitCH395InfParam
   22          * Description    : åˆå§‹åŒ–CH395Infå‚æ•°
   23          * Input          : None
   24          * Output         : None
   25          * Return         : None
   26          *******************************************************************************/
   27          void InitCH395InfParam(void)
   28          {
   29   1          memset(&CH395Inf,0,sizeof(CH395Inf));                            /* å°†CH395Infå…¨éƒ¨æ¸…é›¶*/
   30   1          memcpy(CH395Inf.IPAddr,CH395IPAddr,sizeof(CH395IPAddr));         /* å°†IPåœ°å€å†™å…¥CH395Infä¸­ */
   31   1          memcpy(CH395Inf.GWIPAddr,CH395GWIPAddr,sizeof(CH395GWIPAddr));   /* å°†ç½‘å…³IPåœ°å€å†™å…¥CH395Infä¸
             -­ */
   32   1          memcpy(CH395Inf.MASKAddr,CH395IPMask,sizeof(CH395IPMask));       /* å°†å­ç½‘æ©ç å†™å…¥CH395Infä¸­ 
             -*/
   33   1      }
   34          
   35          /********************************************************************************
   36          * Function Name  : mStopIfError
   37          * Description    : è°ƒè¯•ä½¿ç”¨ï¼Œæ˜¾ç¤ºé”™è¯¯ä»£ç ï¼Œå¹¶åœæœº
   38          * Input          : iError
   39          * Output         : None
   40          * Return         : None
   41          *******************************************************************************/
   42          void mStopIfError(UINT8 iError)
   43          {
   44   1          if (iError == CMD_ERR_SUCCESS) return;                           /* æ“ä½œæˆåŠŸ */
   45   1          printf("Error: %02X\n", (UINT16)iError);                         /* æ˜¾ç¤ºé”™è¯¯ */
   46   1          while ( 1 ) 
   47   1          {
   48   2              mDelaymS(200);
   49   2              mDelaymS(200);
   50   2          }
   51   1      }
   52          
   53          /*******************************************************************************
   54          * Function Name  : InitSocketParam
C251 COMPILER V5.60.0,  CH395                                                              24/03/23  00:55:41  PAGE 2   

   55          * Description    : åˆå§‹åŒ–socket
   56          * Input          : None
   57          * Output         : None
   58          * Return         : None
   59          *******************************************************************************/
   60          void InitSocketParam(void)
   61          {
   62   1          memset(&SockInf,0,sizeof(SockInf));                              /* å°†SockInf[0]å…¨éƒ¨æ¸…é›¶*/
   63   1          SockInf.SourPort = Socket0SourPort;                              /* æºç«¯å£ */
   64   1          SockInf.ProtoType = PROTO_TYPE_TCP;                              /* TCPæ¨¡å¼ */
   65   1          SockInf.TcpMode = TCP_SERVER_MODE;
   66   1      }
   67          
   68          /********************************************************************************
   69          * Function Name  : CH395SocketInitOpen
   70          * Description    : é…ç½®CH395 socket å‚æ•°ï¼Œåˆå§‹åŒ–å¹¶æ‰“å¼€socket
   71          * Input          : None
   72          * Output         : None
   73          * Return         : None
   74          *******************************************************************************/
   75          void CH395SocketInitOpen(void)
   76          {
   77   1          UINT8 i;
   78   1          /* socket 0ä¸ºTCP æœåŠ¡å™¨æ¨¡å¼ */
   79   1          CH395SetSocketDesIP(0,SockInf.IPAddr);                           /* è®¾ç½®socket 0ç›®æ ‡IPåœ°å€ */  
             -       
   80   1          CH395SetSocketProtType(0,SockInf.ProtoType);                     /* è®¾ç½®socket 0åè®®ç±»å‹ */
   81   1          CH395SetSocketDesPort(0,SockInf.DesPort);                        /* è®¾ç½®socket 0ç›®çš„ç«¯å£ */
   82   1          CH395SetSocketSourPort(0,SockInf.SourPort);                      /* è®¾ç½®socket 0æºç«¯å£ */
   83   1          i = CH395OpenSocket(0);                                          /* æ‰“å¼€socket 0 */
   84   1          mStopIfError(i);                                                 /* æ£€æŸ¥æ˜¯å¦æˆåŠŸ */
   85   1          i = CH395TCPListen(0);                                           /* TCPè¿æ¥ */
   86   1          mStopIfError(i);                                                 /* æ£€æŸ¥æ˜¯å¦æˆåŠŸ */
   87   1      }
   88          
   89          /*******************************************************************************
   90          * Function Name  : CH395SocketInterrupt
   91          * Description    : CH395 socket ä¸­æ–­,åœ¨å…¨å±€ä¸­æ–­ä¸­è¢«è°ƒç”¨
   92          * Input          : sockindex
   93          * Output         : None
   94          * Return         : None
   95          *******************************************************************************/
   96          void CH395SocketInterrupt(UINT8 sockindex)
   97          {
   98   1         UINT8  sock_int_socket;
   99   1         UINT8  buf[10],s;
  100   1         memcpy (lastip,CH395IPAddr,4);
  101   1         lastport = Socket0SourPort ;
  102   1         sock_int_socket = CH395GetSocketInt(sockindex);                   /* è·å–socket çš„ä¸­æ–­çŠ¶æ€ */
  103   1         if(sock_int_socket & SINT_STAT_SENBUF_FREE)                       /* å‘é€ç¼“å†²åŒºç©ºé—²ï¼Œå¯ä»¥ç»§
             -ç»­å†™å…¥è¦å‘é€çš„æ•°æ® */
  104   1         {
  105   2            printf("SINT_STAT_SENBUF_FREE\n");   
  106   2            if(SockInf.SendLen >= SockInf.RemLen)
  107   2             {
  108   3              SockInf.RemLen = 0;                                          /* æ•°æ®å·²ç»å‘é€å®Œæ¯• */
  109   3              CH395TCPDisconnect(0);
  110   3             }
  111   2           else
  112   2             {
  113   3              SockInf.pSend += SockInf.SendLen;                           /* å¯¹å‘é€æŒ‡é’ˆè¿›è¡Œåç§» */
  114   3              SockInf.RemLen -= SockInf.SendLen;                          /* è®¡ç®—å‰©ä½™é•¿åº¦ */
  115   3              if(SockInf.RemLen > 2048)SockInf.SendLen = 2048;            /* è®¡ç®—æœ¬æ¬¡å¯ä»¥å‘é€çš„æ•°æ®é
             -•¿åº¦ */
  116   3              else SockInf.SendLen = SockInf.RemLen;    
  117   3              CH395SendData(sockindex,SockInf.pSend,SockInf.SendLen);     /* å‘é€æ•°æ® */
C251 COMPILER V5.60.0,  CH395                                                              24/03/23  00:55:41  PAGE 3   

  118   3             }
  119   2         }
  120   1         if(sock_int_socket & SINT_STAT_SEND_OK)                           /* å‘é€å®Œæˆä¸­æ–­ */
  121   1         {
  122   2         }
  123   1         if(sock_int_socket & SINT_STAT_RECV)                              /* æ¥æ”¶ä¸­æ–­ */
  124   1         {
  125   2             printf("SINT_STAT_RECV\n");
  126   2             len = CH395GetRecvLength(sockindex);                          /* è·å–å½“å‰ç¼“å†²åŒºå†…æ•°æ®é•¿
             -åº¦ */
  127   2             if(len == 0)return;
  128   2             CH395GetRecvData(sockindex,len,RecvBuffer);                   /* è¯»å–æ•°æ® */
  129   2             flag  |= RECVDATA;
  130   2         }
  131   1         if(sock_int_socket & SINT_STAT_CONNECT)                           /* è¿æ¥ä¸­æ–­ï¼Œä»…åœ¨TCPæ¨¡å¼ä¸‹
             -æœ‰æ•ˆ*/
  132   1         {
  133   2            printf("Tcp Connect\n");
  134   2            if(SockInf.TcpMode == TCP_SERVER_MODE)                         /* å¦‚æœsocket ä¸ºæœåŠ¡å™¨æ¨¡å¼ï¼
             -Œç”¨æˆ·å¯ä»¥è·å–è¿œç«¯çš„IPå’Œç«¯å£*/
  135   2            {
  136   3             CH395CMDGetRemoteIPP(sockindex,buf);
  137   3             printf("IP address = %d.%d.%d.%d\n",(UINT16)buf[0],(UINT16)buf[1],(UINT16)buf[2],(UINT16)buf[3]); 
             -       
  138   3            }
  139   2         }
  140   1         if(sock_int_socket & SINT_STAT_DISCONNECT)                        /* æ–­å¼€ä¸­æ–­ï¼Œä»…åœ¨TCPæ¨¡å¼ä¸‹
             -æœ‰æ•ˆ */
  141   1         {
  142   2            printf("SINT_STAT_DISCONNECT\n");
  143   2            s = CH395OpenSocket(0);                                        /* æ‰“å¼€socket 0 */
  144   2            mStopIfError(s);                                               /* æ£€æŸ¥æ˜¯å¦æˆåŠŸ */
  145   2            s = CH395TCPListen(0);                                         /* TCPè¿æ¥ */
  146   2            mStopIfError(s);  
  147   2      
  148   2         }
  149   1         if(sock_int_socket & SINT_STAT_TIM_OUT)                           /* è¶…æ—¶ä¸­æ–­ï¼Œä»…åœ¨TCPæ¨¡å¼ä¸‹
             -æœ‰æ•ˆ */
  150   1         {
  151   2             printf("Tcp Time out\n");
  152   2         }
  153   1      }
  154          
  155          /*******************************************************************************
  156          * Function Name  : CH395GlobalInterrupt
  157          * Description    : CH395å…¨å±€ä¸­æ–­å‡½æ•°
  158          * Input          : None
  159          * Output         : None
  160          * Return         : None
  161          *******************************************************************************/
  162          void CH395GlobalInterrupt(void)
  163          {
  164   1          UINT16 init_status;
  165   1          UINT8  buf[10]; 
  166   1          init_status = CH395CMDGetGlobIntStatus_ALL();
  167   1          if(init_status & GINT_STAT_UNREACH)                              /* ä¸å¯è¾¾ä¸­æ–­ï¼Œè¯»å–ä¸å¯è¾¾
             -ä¿¡æ¯ */
  168   1          {
  169   2              printf("Init status : GINT_STAT_UNREACH\n");                 /* UDPæ¨¡å¼ä¸‹å¯èƒ½ä¼šäº§ç”Ÿä¸å¯
             -è¾¾ä¸­æ–­ */
  170   2              CH395CMDGetUnreachIPPT(buf);                                
  171   2          }
  172   1          if(init_status & GINT_STAT_IP_CONFLI)                            /* äº§ç”ŸIPå†²çªä¸­æ–­ï¼Œå»ºè®®é‡æ
             -–°ä¿®æ”¹CH395çš„ IPï¼Œå¹¶åˆå§‹åŒ–CH395*/
  173   1          {
  174   2          }
C251 COMPILER V5.60.0,  CH395                                                              24/03/23  00:55:41  PAGE 4   

  175   1          if(init_status & GINT_STAT_PHY_CHANGE)                           /* äº§ç”ŸPHYæ”¹å˜ä¸­æ–­*/
  176   1          {
  177   2              printf("Init status : GINT_STAT_PHY_CHANGE\n");
  178   2          }
  179   1          if(init_status & GINT_STAT_SOCK0)
  180   1          {
  181   2              CH395SocketInterrupt(0);                                     /* å¤„ç†socket 0ä¸­æ–­*/
  182   2          }
  183   1          if(init_status & GINT_STAT_SOCK1)                                
  184   1          {
  185   2              CH395SocketInterrupt(1);                                     /* å¤„ç†socket 1ä¸­æ–­*/
  186   2          }
  187   1          if(init_status & GINT_STAT_SOCK2)                                
  188   1          {
  189   2              CH395SocketInterrupt(2);                                     /* å¤„ç†socket 2ä¸­æ–­*/
  190   2          }
  191   1          if(init_status & GINT_STAT_SOCK3)                                
  192   1          {
  193   2              CH395SocketInterrupt(3);                                     /* å¤„ç†socket 3ä¸­æ–­*/
  194   2          }
  195   1          if(init_status & GINT_STAT_SOCK4)
  196   1          {
  197   2              CH395SocketInterrupt(4);                                     /* å¤„ç†socket 4ä¸­æ–­*/
  198   2          }
  199   1          if(init_status & GINT_STAT_SOCK5)                                
  200   1          {
  201   2              CH395SocketInterrupt(5);                                     /* å¤„ç†socket 5ä¸­æ–­*/
  202   2          }
  203   1          if(init_status & GINT_STAT_SOCK6)                                
  204   1          {
  205   2              CH395SocketInterrupt(6);                                     /* å¤„ç†socket 6ä¸­æ–­*/
  206   2          }
  207   1          if(init_status & GINT_STAT_SOCK7)                                
  208   1          {
  209   2              CH395SocketInterrupt(7);                                     /* å¤„ç†socket 7ä¸­æ–­*/
  210   2          }
  211   1      }
  212          
  213          /********************************************************************************
  214          * Function Name  : CH395Init
  215          * Description    : é…ç½®CH395çš„IP,GWIP,MACç­‰å‚æ•°ï¼Œå¹¶åˆå§‹åŒ–
  216          * Input          : None
  217          * Output         : None
  218          * Return         : å‡½æ•°æ‰§è¡Œç»“æœ
  219          *******************************************************************************/
  220          UINT8  CH395Init(void)
  221          {
  222   1          UINT8 i;
  223   1          i = CH395CMDCheckExist(0x65); 
  224   1          printf("CH395CMDCheckExist = %2x\n",(UINT16)i);                     
  225   1          if(i != 0x9a)return CH395_ERR_UNKNOW;                            /* æµ‹è¯•å‘½ä»¤ï¼Œå¦‚æœæ— æ³•é€šè¿‡
             -è¿”å›0XFA */
  226   1          CH395CMDSetIPAddr(CH395Inf.IPAddr);                              /* è®¾ç½®CH395çš„IPåœ°å€ */
  227   1          CH395CMDSetGWIPAddr(CH395Inf.GWIPAddr);                          /* è®¾ç½®ç½‘å…³åœ°å€ */
  228   1          CH395CMDSetMASKAddr(CH395Inf.MASKAddr);                          /* è®¾ç½®å­ç½‘æ©ç ï¼Œé»˜è®¤ä¸º255
             -.255.255.0*/   
  229   1          i = CH395CMDInitCH395();                                         /* åˆå§‹åŒ–CH395èŠ¯ç‰‡ */
  230   1          printf("CH395CMDInitCH395 = %2x\n",(UINT16)i); 
  231   1          return i;
  232   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       823     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
C251 COMPILER V5.60.0,  CH395                                                              24/03/23  00:55:41  PAGE 5   

  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =        64     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       247     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
