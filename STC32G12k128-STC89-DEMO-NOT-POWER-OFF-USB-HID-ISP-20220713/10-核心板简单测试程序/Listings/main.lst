C251 COMPILER V5.60.0,  main                                                               09/07/22  14:00:38  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE main
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C251\BIN\C251.EXE main.c XSMALL INTR2 BROWSE DEBUG PRINT(.\Listings\main.lst) OBJECT(.\O
                    -bjects\main.obj) 

stmt  level    source

    1          /*---------------------------------------------------------------------*/
    2          /* --- STC MCU Limited ------------------------------------------------*/
    3          /* --- STC 1T Series MCU Demo Programme -------------------------------*/
    4          /* --- Mobile: (86)13922805190 ----------------------------------------*/
    5          /* --- Fax: 86-0513-55012956,55012947,55012969 ------------------------*/
    6          /* --- Tel: 86-0513-55012928,55012929,55012966 ------------------------*/
    7          /* --- Web: www.STCMCU.com --------------------------------------------*/
    8          /* --- Web: www.STCMCUDATA.com  ---------------------------------------*/
    9          /* --- QQ:  800003751 -------------------------------------------------*/
   10          /* 如果要在程序中使用此代码,请在程序中注明使用了STC的资料及程序            */
   11          /*---------------------------------------------------------------------*/
   12          
   13          /*************  功能说明    **************
   14          
   15          本例程基于STC32G转STC89系列转接板（降龙棍）进行编写测试。
   16          
   17          上电通过测量内部15通道ADC，反推外部电源电压，电源电压在 4.7V~5.3V 之间正常，反之报错。
   18          
   19          所有LED灯间隔一个交替闪烁，如果相邻的LED灯同时亮/灭，说明两者之间有短路。
   20          
   21          串口4向串口3发送累加数据，串口3收到后与发送值比较，不同的话报错。
   22          
   23          报错时所有LED灯同时快速亮/灭。
   24          
   25          注意：
   26          1. P5.4口LED需要短接 JP1 才能亮。
   27          2. 串口3，串口4通信测试需要连接 R52 电阻。
   28          
   29          此外程序演示两种复位进入USB下载模式的方法：
   30          1. 通过每1毫秒执行一次“KeyResetScan”函数，实现长按P3.2口按键触发MCU复位，进入USB下载模式。
   31          2. 通过加载“stc_usb_hid_32g.lib”库函数，实现使用STC-ISP软件发送指令触发MCU复位，进入USB下载模式并自动下
             -载。
   32          
   33          下载时, 选择时钟 24MHZ (用户可自行修改频率)。
   34          
   35          ******************************************/
   36          
   37          #include "../comm/STC32G.h"  //包含此头文件后，不需要再包含"reg51.h"头文件
   38          #include "../comm/usb.h"     //USB调试及复位所需头文件
   39          #include "intrins.h"
   40          
   41          /****************************** 用户定义宏 ***********************************/
   42          
   43          #define MAIN_Fosc       24000000L   //定义主时钟
   44          #define Timer0_Reload   (65536UL -(MAIN_Fosc / 1000))       //Timer 0 中断频率, 1000次/秒
   45          
   46          #define Baudrate3   115200UL
   47          #define Baudrate4   115200UL
   48          
   49          #define UART3_BUF_LENGTH    64
   50          #define UART4_BUF_LENGTH    64
   51          
   52          /*****************************************************************************/
   53          
   54          u16 Bandgap;
   55          u16 vcc;
   56          
   57          u8  TX_Data;    //发送数据
C251 COMPILER V5.60.0,  main                                                               09/07/22  14:00:38  PAGE 2   

   58          
   59          u8  TX3_Cnt;    //发送计数
   60          u8  RX3_Cnt;    //接收计数
   61          u8  TX4_Cnt;    //发送计数
   62          u8  RX4_Cnt;    //接收计数
   63          bit B_Err_Flag; //错误标志
   64          bit B_TX3_Busy; //发送忙标志
   65          bit B_TX4_Busy; //发送忙标志
   66          u8 RX3_TimeOut;
   67          u8 RX4_TimeOut;
   68          
   69          u8  xdata RX3_Buffer[UART3_BUF_LENGTH]; //接收缓冲
   70          u8  xdata RX4_Buffer[UART4_BUF_LENGTH]; //接收缓冲
   71          
   72          //USB调试及复位所需定义
   73          char *USER_DEVICEDESC = NULL;
   74          char *USER_PRODUCTDESC = NULL;
   75          char *USER_STCISPCMD = "@STCISP#";                      //设置自动复位到ISP区的用户接口命令
   76          
   77          //P3.2口按键复位所需变量
   78          bit Key_Flag;
   79          u16 Key_cnt;
   80          
   81          void Timer0_Init(void);
   82          void ADC_Init(void);
   83          u16  Get_ADC12bitResult(u8 channel); //channel = 0~15
   84          void delay_ms(u8 ms);
   85          void TestError(void);
   86          void TestIO(void);
   87          void UART3_config(u8 brt);   // 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer3做波特率.
   88          void UART4_config(u8 brt);   // 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer4做波特率.
   89          void UART3_TxByte(u8 dat);
   90          void UART4_TxByte(u8 dat);
   91          void KeyResetScan(void);
   92          
   93          /******************** 主函数 **************************/
   94          void main(void)
   95          {
   96   1          u8  i;
   97   1          u16 j;
   98   1          WTST = 0;  //设置程序指令延时参数，赋值为0可将CPU执行指令的速度设置为最快
   99   1          EAXFR = 1; //扩展寄存器(XFR)访问使能
  100   1          CKCON = 0; //提高访问XRAM速度
  101   1      
  102   1          P0M1 = 0x00;   P0M0 = 0x00;   //设置为准双向口
  103   1          P1M1 = 0x00;   P1M0 = 0x00;   //设置为准双向口
  104   1          P2M1 = 0x00;   P2M0 = 0x00;   //设置为准双向口
  105   1          P3M1 = 0x00;   P3M0 = 0x00;   //设置为准双向口
  106   1          P4M1 = 0x00;   P4M0 = 0x00;   //设置为准双向口
  107   1          P5M1 = 0x00;   P5M0 = 0x00;   //设置为准双向口
  108   1          P6M1 = 0x00;   P6M0 = 0x00;   //设置为准双向口
  109   1          P7M1 = 0x00;   P7M0 = 0x00;   //设置为准双向口
  110   1      
  111   1          //USB调试及复位所需代码-----
  112   1          P3M0 &= ~0x03;
  113   1          P3M1 |= 0x03;
  114   1          IRC48MCR = 0x80;
  115   1          while (!(IRC48MCR & 0x01));
  116   1          usb_init();
  117   1          //-------------------------
  118   1      
  119   1          Timer0_Init();
  120   1          ADC_Init();
  121   1          UART3_config(3);    // 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer3做波特率.
  122   1          UART4_config(4);    // 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer4做波特率.
  123   1          EUSB = 1;   //IE2相关的中断使能后，需要重新设置EUSB
C251 COMPILER V5.60.0,  main                                                               09/07/22  14:00:38  PAGE 3   

  124   1          EA = 1;     //打开总中断
  125   1      
  126   1          delay_ms(2);
  127   1          Bandgap = (CHIPID7 << 8) + CHIPID8;
  128   1          B_Err_Flag = 0;
  129   1          
  130   1          Get_ADC12bitResult(15);  //先读一次并丢弃结果, 让内部的采样电容的电压等于输入值.
  131   1          Get_ADC12bitResult(15);  //先读一次并丢弃结果, 让内部的采样电容的电压等于输入值.
  132   1          for(j=0, i=0; i<16; i++)
  133   1          {
  134   2              j += Get_ADC12bitResult(15); //读内部基准ADC, 读15通道
  135   2          }
  136   1          j >>= 4;   //16次平均
  137   1      
  138   1          vcc = (int)(4096L * Bandgap / j);            //(12位ADC算法)计算VREF管脚电压,即电池电压
  139   1          
  140   1          if((vcc < 4700) || (vcc > 5300))
  141   1          {
  142   2      //        P0 = vcc >> 8;  //IO 口显示测量结果
  143   2      //        P2 = vcc;
  144   2      //        while(1);
  145   2              TestError();
  146   2          }
  147   1          else
  148   1          {
  149   2              while(1)
  150   2              {
  151   3                  TestIO();
  152   3                  UART4_TxByte(++TX_Data);  //发送计数值给串口3
  153   3                  if(B_Err_Flag)
  154   3                  {
  155   4                      TestError();
  156   4                  }
  157   3              }
  158   2          }
  159   1      }
  160          
  161          /********************** Timer0 1ms中断函数 ************************/
  162          void timer0(void) interrupt 1
  163          {
  164   1          if(RX3_TimeOut > 0)     //超时计数
  165   1          {
  166   2              if(--RX3_TimeOut == 0)
  167   2              {
  168   3                  if(RX3_Buffer[0] != TX_Data) B_Err_Flag = 1;  //判断串口3收到的数据是否正确
  169   3                  RX3_Cnt  = 0;   //清除字节数
  170   3              }
  171   2          }
  172   1      
  173   1          if (bUsbOutReady) //USB调试及复位所需代码
  174   1          {
  175   2      //        memcpy(UsbInBuffer, UsbOutBuffer, 64);      //原路返回, 用于测试HID
  176   2      //        usb_IN();
  177   2              
  178   2              usb_OUT_done();
  179   2          }
  180   1      
  181   1          KeyResetScan();   //P3.2口按键触发软件复位，进入USB下载模式，不需要此功能可删除本行代码
  182   1      }
  183          
  184          //========================================================================
  185          // 函数: void TestError(void)
  186          // 描述: 延时函数。
  187          // 参数: none.
  188          // 返回: none.
  189          // 版本: VER1.0
C251 COMPILER V5.60.0,  main                                                               09/07/22  14:00:38  PAGE 4   

  190          // 日期: 2022-6-2
  191          // 备注: 
  192          //========================================================================
  193          void TestError(void)
  194          {
  195   1          while(1)
  196   1          {
  197   2              P0 = 0;         //LED On
  198   2              P1 = 0;         //LED On
  199   2              P2 = 0;         //LED On
  200   2              P3 = 0;         //LED On
  201   2              P4 = 0;         //LED On
  202   2              P5 = 0;         //LED On
  203   2              P6 = 0;         //LED On
  204   2              P7 = 0;         //LED On
  205   2              delay_ms(250);
  206   2              P0 = 0xff;      //LED Off
  207   2              P1 = 0xff;      //LED Off
  208   2              P2 = 0xff;      //LED Off
  209   2              P3 = 0xff;      //LED Off
  210   2              P4 = 0xff;      //LED Off
  211   2              P5 = 0xff;      //LED Off
  212   2              P6 = 0xff;      //LED Off
  213   2              P7 = 0xff;      //LED Off
  214   2              delay_ms(250);
  215   2          }
  216   1      }
  217          
  218          //========================================================================
  219          // 函数: void TestIO(void)
  220          // 描述: 延时函数。
  221          // 参数: none.
  222          // 返回: none.
  223          // 版本: VER1.0
  224          // 日期: 2022-6-2
  225          // 备注: 
  226          //========================================================================
  227          void TestIO(void)
  228          {
  229   1          P0 = 0x55;  //LED On
  230   1          P1 = 0x55;  //LED On
  231   1          P3 = 0x55;  //LED On
  232   1          P2 = 0xaa;  //LED Off
  233   1          P52 = 1;    //LED Off
  234   1          P45 = 1;    //LED Off
  235   1          P46 = 1;    //LED Off
  236   1          P47 = 0;    //LED On
  237   1          P54 = 0;    //LED On
  238   1      
  239   1          delay_ms(250);
  240   1          delay_ms(250);
  241   1          P0 = 0xaa;  //LED Off
  242   1          P1 = 0xaa;  //LED Off
  243   1          P3 = 0xaa;  //LED Off
  244   1          P2 = 0x55;  //LED On
  245   1          P52 = 0;    //LED On
  246   1          P45 = 0;    //LED On
  247   1          P46 = 0;    //LED On
  248   1          P47 = 1;    //LED Off
  249   1          P54 = 1;    //LED Off
  250   1      
  251   1          delay_ms(250);
  252   1          delay_ms(250);
  253   1          delay_ms(250);
  254   1      }
  255          
C251 COMPILER V5.60.0,  main                                                               09/07/22  14:00:38  PAGE 5   

  256          //========================================================================
  257          // 函数: void Timer0_Init(void)
  258          // 描述: 定时器0初始化函数。
  259          // 参数: none.
  260          // 返回: none.
  261          // 版本: VER1.0
  262          // 日期: 2022-6-2
  263          // 备注: 
  264          //========================================================================
  265          void Timer0_Init(void)
  266          {
  267   1          //  Timer0初始化
  268   1          AUXR = 0x80;    //Timer0 set as 1T, 16 bits timer auto-reload, 
  269   1          TH0 = (u8)(Timer0_Reload / 256);
  270   1          TL0 = (u8)(Timer0_Reload % 256);
  271   1          ET0 = 1;    //Timer0 interrupt enable
  272   1          TR0 = 1;    //Tiner0 run
  273   1      }
  274          
  275          //========================================================================
  276          // 函数: void ADC_Init(void)
  277          // 描述: ADC初始化函数。
  278          // 参数: none.
  279          // 返回: none.
  280          // 版本: VER1.0
  281          // 日期: 2022-6-2
  282          // 备注: 
  283          //========================================================================
  284          void ADC_Init(void)
  285          {
  286   1          ADCTIM = 0x3f;              //设置 ADC 内部时序，ADC采样时间建议设最大值
  287   1          ADCCFG = 0x2f;              //设置 ADC 时钟为系统时钟/2/16
  288   1          ADC_CONTR = 0x8f;   //使能 ADC 模块
  289   1      }
  290          
  291          //========================================================================
  292          // 函数: u16 Get_ADC12bitResult(u8 channel)
  293          // 描述: 查询法读一次ADC结果.
  294          // 参数: channel: 选择要转换的ADC.
  295          // 返回: 12位ADC结果.
  296          // 版本: V1.0, 2012-10-22
  297          //========================================================================
  298          u16 Get_ADC12bitResult(u8 channel)  //channel = 0~15
  299          {
  300   1          ADC_RES = 0;
  301   1          ADC_RESL = 0;
  302   1      
  303   1          ADC_CONTR = (ADC_CONTR & 0xf0) | channel; //设置ADC转换通道
  304   1          ADC_START = 1;//启动ADC转换
  305   1          _nop_();
  306   1          _nop_();
  307   1          _nop_();
  308   1          _nop_();
  309   1      
  310   1          while(ADC_FLAG == 0);   //wait for ADC finish
  311   1          ADC_FLAG = 0;     //清除ADC结束标志
  312   1          return  (((u16)ADC_RES << 8) | ADC_RESL);
  313   1      }
  314          
  315          //========================================================================
  316          // 函数: void delay_ms(u8 ms)
  317          // 描述: 延时函数。
  318          // 参数: ms,要延时的ms数, 这里只支持1~255ms. 自动适应主时钟.
  319          // 返回: none.
  320          // 版本: VER1.0
  321          // 日期: 2021-3-9
C251 COMPILER V5.60.0,  main                                                               09/07/22  14:00:38  PAGE 6   

  322          // 备注: 
  323          //========================================================================
  324          void delay_ms(u8 ms)
  325          {
  326   1           u16 i;
  327   1           do{
  328   2                i = MAIN_Fosc / 6000;
  329   2                while(--i);   //6T per loop
  330   2           }while(--ms);
  331   1      }
  332          
  333          //========================================================================
  334          // 函数: void UART3_TxByte(u8 dat)
  335          // 描述: 发送一个字节.
  336          // 参数: 无.
  337          // 返回: 无.
  338          // 版本: V1.0, 2014-6-30
  339          //========================================================================
  340          //void UART3_TxByte(u8 dat)
  341          //{
  342          //    B_TX3_Busy = 1;
  343          //    S3BUF = dat;
  344          //    while(B_TX3_Busy);
  345          //}
  346          
  347          //========================================================================
  348          // 函数: void UART4_TxByte(u8 dat)
  349          // 描述: 发送一个字节.
  350          // 参数: 无.
  351          // 返回: 无.
  352          // 版本: V1.0, 2014-6-30
  353          //========================================================================
  354          void UART4_TxByte(u8 dat)
  355          {
  356   1          B_TX4_Busy = 1;
  357   1          S4BUF = dat;
  358   1          while(B_TX4_Busy);
  359   1      }
  360          
  361          //========================================================================
  362          // 函数: void PrintString3(u8 *puts)
  363          // 描述: 串口3发送字符串函数。
  364          // 参数: puts:  字符串指针.
  365          // 返回: none.
  366          // 版本: VER1.0
  367          // 日期: 2014-11-28
  368          // 备注: 
  369          //========================================================================
  370          //void PrintString3(u8 *puts)
  371          //{
  372          //    for (; *puts != 0;  puts++)     //遇到停止符0结束
  373          //    {
  374          //        UART3_TxByte(*puts);
  375          //    }
  376          //}
  377          
  378          //========================================================================
  379          // 函数: void PrintString4(u8 *puts)
  380          // 描述: 串口4发送字符串函数。
  381          // 参数: puts:  字符串指针.
  382          // 返回: none.
  383          // 版本: VER1.0
  384          // 日期: 2014-11-28
  385          // 备注: 
  386          //========================================================================
  387          //void PrintString4(u8 *puts)
C251 COMPILER V5.60.0,  main                                                               09/07/22  14:00:38  PAGE 7   

  388          //{
  389          //    for (; *puts != 0;  puts++)     //遇到停止符0结束
  390          //    {
  391          //        UART4_TxByte(*puts);
  392          //    }
  393          //}
  394          
  395          //========================================================================
  396          // 函数: SetTimer2Baudraye(u16 dat)
  397          // 描述: 设置Timer2做波特率发生器。
  398          // 参数: dat: Timer2的重装值.
  399          // 返回: none.
  400          // 版本: VER1.0
  401          // 日期: 2014-11-28
  402          // 备注: 
  403          //========================================================================
  404          void SetTimer2Baudraye(u16 dat)
  405          {
  406   1          T2R = 0;            //Timer stop
  407   1          T2_CT = 0;  //Timer2 set As Timer
  408   1          T2x12 = 1;  //Timer2 set as 1T mode
  409   1          T2H = (u8)(dat / 256);
  410   1          T2L = (u8)(dat % 256);
  411   1          ET2 = 0;    //禁止中断
  412   1          T2R = 1;            //Timer run enable
  413   1      }
  414          
  415          //========================================================================
  416          // 函数: void UART3_config(u8 brt)
  417          // 描述: UART3初始化函数。
  418          // 参数: brt: 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer3做波特率.
  419          // 返回: none.
  420          // 版本: VER1.0
  421          // 日期: 2014-11-28
  422          // 备注: 
  423          //========================================================================
  424          void UART3_config(u8 brt)    // 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer3做波特率.
  425          {
  426   1          if(brt == 2)
  427   1          {
  428   2              SetTimer2Baudraye((u16)(65536UL - (MAIN_Fosc / 4) / Baudrate3));
  429   2              S3CON = 0x10;       //8位数据, 使用Timer2做波特率发生器, 允许接收
  430   2          }
  431   1          else
  432   1          {
  433   2              T3R = 0;                //Timer stop
  434   2              S3CON = 0x50;       //8位数据, 使用Timer3做波特率发生器, 允许接收
  435   2              T3H = (65536UL - (MAIN_Fosc / 4) / Baudrate3) / 256;
  436   2              T3L = (65536UL - (MAIN_Fosc / 4) / Baudrate3) % 256;
  437   2              T3_CT = 0;      //Timer3 set As Timer
  438   2              T3x12 = 1;      //Timer3 set as 1T mode
  439   2              T3R = 1;                //Timer run enable
  440   2          }
  441   1          ES3  = 1;       //允许UART3中断
  442   1          S3_S = 1;       //UART3 switch bit1 to: 0: P0.0 P0.1,  1: P5.0 P5.1
  443   1      
  444   1          B_TX3_Busy = 0;
  445   1          TX3_Cnt = 0;
  446   1          RX3_Cnt = 0;
  447   1      }
  448          
  449          //========================================================================
  450          // 函数: void UART4_config(u8 brt)
  451          // 描述: UART4初始化函数。
  452          // 参数: brt: 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer4做波特率.
  453          // 返回: none.
C251 COMPILER V5.60.0,  main                                                               09/07/22  14:00:38  PAGE 8   

  454          // 版本: VER1.0
  455          // 日期: 2014-11-28
  456          // 备注: 
  457          //========================================================================
  458          void UART4_config(u8 brt)    // 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer4做波特率.
  459          {
  460   1          if(brt == 2)
  461   1          {
  462   2              SetTimer2Baudraye((u16)(65536UL - (MAIN_Fosc / 4) / Baudrate4));
  463   2              S4CON = 0x10;       //8位数据, 使用Timer2做波特率发生器, 允许接收
  464   2          }
  465   1          else
  466   1          {
  467   2              T4R = 0;        //Timer stop
  468   2              S4CON = 0x50;       //8位数据, 使用Timer4做波特率发生器, 允许接收
  469   2              T4H = (65536UL - (MAIN_Fosc / 4) / Baudrate4) / 256;
  470   2              T4L = (65536UL - (MAIN_Fosc / 4) / Baudrate4) % 256;
  471   2              T4_CT = 0;      //Timer3 set As Timer
  472   2              T4x12 = 1;      //Timer3 set as 1T mode
  473   2              T4R = 1;        //Timer run enable
  474   2          }
  475   1          ES4  = 1;       //允许UART4中断
  476   1          S4_S = 0;       //UART4 switch bit2 to: 0: P0.2 P0.3, 1: P5.2 P5.3
  477   1      
  478   1          B_TX4_Busy = 0;
  479   1          TX4_Cnt = 0;
  480   1          RX4_Cnt = 0;
  481   1      }
  482          
  483          //========================================================================
  484          // 函数: void UART3_int (void) interrupt UART3_VECTOR
  485          // 描述: UART3中断函数。
  486          // 参数: nine.
  487          // 返回: none.
  488          // 版本: VER1.0
  489          // 日期: 2014-11-28
  490          // 备注: 
  491          //========================================================================
  492          void UART3_int (void) interrupt 17
  493          {
  494   1          if(S3RI)
  495   1          {
  496   2              S3RI = 0;    //Clear Rx flag
  497   2              RX3_Buffer[RX3_Cnt] = S3BUF;
  498   2              if(++RX3_Cnt >= UART3_BUF_LENGTH)   RX3_Cnt = 0;
  499   2              RX3_TimeOut = 5;
  500   2          }
  501   1      
  502   1          if(S3TI)
  503   1          {
  504   2              S3TI = 0;   //Clear Tx flag
  505   2              B_TX3_Busy = 0;
  506   2          }
  507   1      }
  508          
  509          //========================================================================
  510          // 函数: void UART4_int (void) interrupt UART4_VECTOR
  511          // 描述: UART4中断函数。
  512          // 参数: nine.
  513          // 返回: none.
  514          // 版本: VER1.0
  515          // 日期: 2014-11-28
  516          // 备注: 
  517          //========================================================================
  518          void UART4_int (void) interrupt 18
  519          {
C251 COMPILER V5.60.0,  main                                                               09/07/22  14:00:38  PAGE 9   

  520   1          if(S4RI)
  521   1          {
  522   2              S4RI = 0;    //Clear Rx flag
  523   2              if(RX4_Cnt >= UART4_BUF_LENGTH)   RX4_Cnt = 0;
  524   2              RX4_Buffer[RX4_Cnt] = S2BUF;
  525   2              RX4_Cnt++;
  526   2              RX4_TimeOut = 5;
  527   2          }
  528   1      
  529   1          if(S4TI)
  530   1          {
  531   2              S4TI = 0;    //Clear Tx flag
  532   2              B_TX4_Busy = 0;
  533   2          }
  534   1      }
  535          
  536          //========================================================================
  537          // 函数: void KeyResetScan(void)
  538          // 描述: P3.2口按键长按1秒触发软件复位，进入USB下载模式。
  539          // 参数: none.
  540          // 返回: none.
  541          // 版本: VER1.0
  542          // 日期: 2022-6-11
  543          // 备注: 
  544          //========================================================================
  545          void KeyResetScan(void)
  546          {
  547   1          if(!P32)
  548   1          {
  549   2              if(!Key_Flag)
  550   2              {
  551   3                  Key_cnt++;
  552   3                  if(Key_cnt >= 1000)         //连续1000ms有效按键检测
  553   3                  {
  554   4                      Key_Flag = 1;           //设置按键状态，防止重复触发
  555   4      
  556   4                      USBCON = 0x00;      //清除USB设置
  557   4                      USBCLK = 0x00;
  558   4                      IRC48MCR = 0x00;
  559   4                      
  560   4                      delay_ms(10);
  561   4                      IAP_CONTR = 0x60;   //触发软件复位，从ISP开始执行
  562   4                      while (1);
  563   4                  }
  564   3              }
  565   2          }
  566   1          else
  567   1          {
  568   2              Key_cnt = 0;
  569   2              Key_Flag = 0;
  570   2          }
  571   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       951     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =       128     ------
  xdata-const size     =    ------     ------
  edata size           =        25     ------
  bit size             =         4     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
C251 COMPILER V5.60.0,  main                                                               09/07/22  14:00:38  PAGE 10  

  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        33     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
